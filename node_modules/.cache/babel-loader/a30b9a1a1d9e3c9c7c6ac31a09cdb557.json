{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar App = {\n  mergeRoadPath: function mergeRoadPath(roadPath, options) {\n    var newRoadPath = [];\n\n    for (var i = 0; i < roadPath.length; i++) {\n      if (newRoadPath.length == 0) {\n        newRoadPath.push(roadPath[i]);\n      } else {\n        var item = roadPath[i].split(',');\n        var last = newRoadPath[newRoadPath.length - 1].split(',');\n\n        if (item[0] === last[last.length - 2] && item[1] === last[last.length - 1]) {\n          var add = item.slice(2);\n          newRoadPath[newRoadPath.length - 1] += ',' + add.join(',');\n        } else {\n          newRoadPath.push(roadPath[i]);\n        }\n      }\n    } // 点去重、性能有问题、先临时去掉\n    // newRoadPath = this.uniqueRoadPath(newRoadPath);\n\n\n    return newRoadPath;\n  },\n  uniqueRoadPath: function uniqueRoadPath(roadPath) {\n    var newRoadPath = [];\n\n    for (var i = 0; i < roadPath.length - 1; i++) {\n      if (!roadPath[i]) {\n        continue;\n      }\n\n      var ref = roadPath[i].split(',');\n\n      for (var j = i + 1; j < roadPath.length; j++) {\n        if (roadPath[j]) {\n          var line = roadPath[j].split(',');\n          var flag = true;\n\n          for (var z = 0; z < line.length; z += 2) {\n            var tmp = this.isPointOnPolyline({\n              lng: line[z],\n              lat: line[z + 1]\n            }, ref);\n\n            if (tmp == false) {\n              flag = false;\n            } else {}\n          }\n\n          if (flag) {\n            delete roadPath[j];\n          }\n        }\n      }\n    }\n\n    return roadPath;\n  },\n\n  /**\n   * 判断点是否在折线上\n   * @param {Point} point 点对象\n   * @param {Polyline} polyline 折线对象\n   * @returns {Boolean} 点在折线上返回true,否则返回false\n   */\n  isPointOnPolyline: function isPointOnPolyline(point, polyline) {\n    //todo首先判断点是否在线的外包矩形内，如果在，则进一步判断，否则返回false\n    //判断点是否在线段上，设点为Q，线段为P1P2 ，\n    //判断点Q在该线段上的依据是：( Q - P1 ) × ( P2 - P1 ) = 0，且 Q 在以 P1，P2为对角顶点的矩形内\n    var pts = polyline;\n\n    for (var i = 0; i < pts.length - 2; i++) {\n      var curPt = {\n        lng: pts[i],\n        lat: pts[i + 1]\n      };\n      var nextPt = {\n        lng: pts[i + 2],\n        lat: pts[i + 3] //首先判断point是否在curPt和nextPt之间，即：此判断该点是否在该线段的外包矩形内\n\n      };\n\n      if (point.lng >= Math.min(curPt.lng, nextPt.lng) && point.lng <= Math.max(curPt.lng, nextPt.lng) && point.lat >= Math.min(curPt.lat, nextPt.lat) && point.lat <= Math.max(curPt.lat, nextPt.lat)) {\n        //判断点是否在直线上公式\n        var precision = (curPt.lng - point.lng) * (nextPt.lat - point.lat) - (nextPt.lng - point.lng) * (curPt.lat - point.lat);\n        var diff = 2e-10;\n        diff = 2e-9;\n\n        if (precision < diff && precision > -diff) {\n          //实质判断是否接近0\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n};\nexports.default = App;","map":null,"metadata":{},"sourceType":"script"}