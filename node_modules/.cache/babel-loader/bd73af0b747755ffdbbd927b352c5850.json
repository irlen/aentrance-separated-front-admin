{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar App = {\n  mergeRoadPath: function mergeRoadPath(roadPath, options) {\n    if (!roadPath) {\n      return;\n    }\n\n    var newRoadPath = [];\n\n    for (var i = 0; i < roadPath.length; i++) {\n      if (newRoadPath.length == 0) {\n        newRoadPath.push(roadPath[i]);\n      } else {\n        var item = roadPath[i].split(',');\n        var isAdd = false;\n\n        for (var j = 0; j < newRoadPath.length; j++) {\n          var last = newRoadPath[j].split(',');\n\n          if (item[0] === last[last.length - 2] && item[1] === last[last.length - 1]) {\n            var add = item.slice(2);\n            newRoadPath[j] += ',' + add.join(',');\n            isAdd = true;\n          }\n\n          if (item[item.length - 2] === last[0] && item[item.length - 1] === last[1]) {\n            var add = item.slice(0, item.length - 2);\n            newRoadPath[j] = add.join(',') + ',' + newRoadPath[j];\n            isAdd = true;\n          }\n        }\n\n        if (isAdd === false) {\n          newRoadPath.push(roadPath[i]);\n        }\n      }\n    }\n\n    newRoadPath = this.uniqueRoadPath(newRoadPath);\n    return newRoadPath;\n  },\n  uniqueRoadPath: function uniqueRoadPath(roadPath) {\n    var tmpRoadPath = roadPath.map(function (line) {\n      return new Polyline(line.split(','));\n    });\n\n    for (var i = 0; i < tmpRoadPath.length - 1; i++) {\n      if (!tmpRoadPath[i]) {\n        continue;\n      }\n\n      var ref = tmpRoadPath[i];\n\n      for (var j = i + 1; j < tmpRoadPath.length; j++) {\n        if (tmpRoadPath[j]) {\n          var line = tmpRoadPath[j];\n\n          if (line.isInclude(ref)) {\n            delete tmpRoadPath[j];\n          }\n        }\n      }\n    }\n\n    var newRoadPath = [];\n    tmpRoadPath.map(function (line) {\n      if (line) {\n        newRoadPath.push(line.getPoints().join(','));\n      }\n    });\n    return newRoadPath;\n  }\n};\n\nfunction Polyline(pts) {\n  this.polyline = pts;\n  var minX = pts[0];\n  var maxX = pts[0];\n  var minY = pts[1];\n  var maxY = pts[1];\n\n  for (var i = 2; i < pts.length; i += 2) {\n    minX = Math.min(minX, pts[i]);\n    maxX = Math.max(maxX, pts[i]);\n    minY = Math.min(minY, pts[i + 1]);\n    maxY = Math.max(maxY, pts[i + 1]);\n  }\n\n  this.minX = minX;\n  this.maxX = maxX;\n  this.minY = minY;\n  this.maxY = maxY;\n}\n\nPolyline.prototype.getPoints = function () {\n  return this.polyline;\n};\n\nPolyline.prototype.isInBound = function (point) {\n  if (point.lng > this.minX && point.lat > this.minY && point.lng < this.maxX && point.lat < this.maxY) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nPolyline.prototype.isInclude = function (polyline) {\n  if (!(polyline.minX > this.minX && polyline.minY > this.minY && polyline.maxX < this.maxX && polyline.maxY < this.maxY)) {\n    return false;\n  }\n\n  var line = this.getPoints();\n  var flag = true;\n\n  for (var z = 0; z < line.length; z += 2) {\n    var tmp = this.isPointOnPolyline({\n      lng: line[z],\n      lat: line[z + 1]\n    }, polyline);\n\n    if (tmp == false) {\n      flag = false;\n    }\n  }\n\n  return flag;\n};\n/**\n * 判断点是否在折线上\n * @param {Point} point 点对象\n * @param {Polyline} polyline 折线对象\n * @returns {Boolean} 点在折线上返回true,否则返回false\n */\n\n\nPolyline.prototype.isPointOnPolyline = function (point, polyline) {\n  var pts = polyline.getPoints();\n\n  if (!polyline.isInBound(point)) {\n    return false;\n  } //判断点是否在线段上，设点为Q，线段为P1P2 ，\n  //判断点Q在该线段上的依据是：( Q - P1 ) × ( P2 - P1 ) = 0，且 Q 在以 P1，P2为对角顶点的矩形内\n\n\n  for (var i = 0; i < pts.length - 2; i++) {\n    var curPt = {\n      lng: pts[i],\n      lat: pts[i + 1]\n    };\n    var nextPt = {\n      lng: pts[i + 2],\n      lat: pts[i + 3] //首先判断point是否在curPt和nextPt之间，即：此判断该点是否在该线段的外包矩形内\n\n    };\n\n    if (point.lng >= Math.min(curPt.lng, nextPt.lng) && point.lng <= Math.max(curPt.lng, nextPt.lng) && point.lat >= Math.min(curPt.lat, nextPt.lat) && point.lat <= Math.max(curPt.lat, nextPt.lat)) {\n      //判断点是否在直线上公式\n      var precision = (curPt.lng - point.lng) * (nextPt.lat - point.lat) - (nextPt.lng - point.lng) * (curPt.lat - point.lat);\n      var diff = 2e-10;\n      diff = 2e-9;\n\n      if (precision < diff && precision > -diff) {\n        //实质判断是否接近0\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nexports.default = App;","map":null,"metadata":{},"sourceType":"script"}