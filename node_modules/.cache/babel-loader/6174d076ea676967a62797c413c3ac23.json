{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _lodash = require(\"lodash.isequal\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _utils = require(\"./utils\");\n\nvar _responsiveUtils = require(\"./responsiveUtils\");\n\nvar _ReactGridLayout = require(\"./ReactGridLayout\");\n\nvar _ReactGridLayout2 = _interopRequireDefault(_ReactGridLayout);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar type = function type(obj) {\n  return Object.prototype.toString.call(obj);\n};\n\nvar ResponsiveReactGridLayout = function (_React$Component) {\n  _inherits(ResponsiveReactGridLayout, _React$Component);\n\n  function ResponsiveReactGridLayout() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ResponsiveReactGridLayout);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = _this.generateInitialState(), _this.onLayoutChange = function (layout) {\n      var _extends2;\n\n      _this.props.onLayoutChange(layout, _extends({}, _this.props.layouts, (_extends2 = {}, _extends2[_this.state.breakpoint] = layout, _extends2)));\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  } // This should only include propTypes needed in this code; RGL itself\n  // will do validation of the rest props passed to it.\n\n\n  ResponsiveReactGridLayout.prototype.generateInitialState = function generateInitialState() {\n    var _props = this.props,\n        width = _props.width,\n        breakpoints = _props.breakpoints,\n        layouts = _props.layouts,\n        cols = _props.cols;\n    var breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);\n    var colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols); // verticalCompact compatibility, now deprecated\n\n    var compactType = this.props.verticalCompact === false ? null : this.props.compactType; // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n    // for this layout.\n\n    var initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);\n    return {\n      layout: initialLayout,\n      breakpoint: breakpoint,\n      cols: colNo\n    };\n  };\n\n  ResponsiveReactGridLayout.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    // Allow parent to set width or breakpoint directly.\n    if (nextProps.width != this.props.width || nextProps.breakpoint !== this.props.breakpoint || !(0, _lodash2.default)(nextProps.breakpoints, this.props.breakpoints) || !(0, _lodash2.default)(nextProps.cols, this.props.cols)) {\n      this.onWidthChange(nextProps);\n    } else if (!(0, _lodash2.default)(nextProps.layouts, this.props.layouts)) {\n      // Allow parent to set layouts directly.\n      var _state = this.state,\n          _breakpoint = _state.breakpoint,\n          _cols = _state.cols; // Since we're setting an entirely new layout object, we must generate a new responsive layout\n      // if one does not exist.\n\n      var newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, _breakpoint, _breakpoint, _cols, nextProps.compactType);\n      this.setState({\n        layout: newLayout\n      });\n    }\n  }; // wrap layouts so we do not need to pass layouts to child\n\n  /**\n   * When the width changes work through breakpoints and reset state with the new width & breakpoint.\n   * Width changes are necessary to figure out the widget widths.\n   */\n\n\n  ResponsiveReactGridLayout.prototype.onWidthChange = function onWidthChange(nextProps) {\n    var breakpoints = nextProps.breakpoints,\n        cols = nextProps.cols,\n        layouts = nextProps.layouts,\n        compactType = nextProps.compactType;\n    var newBreakpoint = nextProps.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(nextProps.breakpoints, nextProps.width);\n    var lastBreakpoint = this.state.breakpoint; // Breakpoint change\n\n    if (lastBreakpoint !== newBreakpoint || this.props.breakpoints !== breakpoints || this.props.cols !== cols) {\n      // Preserve the current layout if the current breakpoint is not present in the next layouts.\n      if (!(lastBreakpoint in layouts)) layouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout); // Find or generate a new layout.\n\n      var newCols = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);\n\n      var _layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType); // This adds missing items.\n\n\n      _layout = (0, _utils.synchronizeLayoutWithChildren)(_layout, nextProps.children, newCols, compactType); // Store the new layout.\n\n      layouts[newBreakpoint] = _layout; // callbacks\n\n      this.props.onLayoutChange(_layout, layouts);\n      this.props.onBreakpointChange(newBreakpoint, newCols);\n      this.props.onWidthChange(nextProps.width, nextProps.margin, newCols, nextProps.containerPadding);\n      this.setState({\n        breakpoint: newBreakpoint,\n        layout: _layout,\n        cols: newCols\n      });\n    }\n  };\n\n  ResponsiveReactGridLayout.prototype.render = function render() {\n    /* eslint-disable no-unused-vars */\n    var _props2 = this.props,\n        breakpoint = _props2.breakpoint,\n        breakpoints = _props2.breakpoints,\n        cols = _props2.cols,\n        layouts = _props2.layouts,\n        onBreakpointChange = _props2.onBreakpointChange,\n        onLayoutChange = _props2.onLayoutChange,\n        onWidthChange = _props2.onWidthChange,\n        other = _objectWithoutProperties(_props2, [\"breakpoint\", \"breakpoints\", \"cols\", \"layouts\", \"onBreakpointChange\", \"onLayoutChange\", \"onWidthChange\"]);\n    /* eslint-enable no-unused-vars */\n\n\n    return _react2.default.createElement(_ReactGridLayout2.default, _extends({}, other, {\n      onLayoutChange: this.onLayoutChange,\n      layout: this.state.layout,\n      cols: this.state.cols\n    }));\n  };\n\n  return ResponsiveReactGridLayout;\n}(_react2.default.Component);\n\nResponsiveReactGridLayout.propTypes = {\n  //\n  // Basic props\n  //\n  // Optional, but if you are managing width yourself you may want to set the breakpoint\n  // yourself as well.\n  breakpoint: _propTypes2.default.string,\n  // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}\n  breakpoints: _propTypes2.default.object,\n  // # of cols. This is a breakpoint -> cols map\n  cols: _propTypes2.default.object,\n  // layouts is an object mapping breakpoints to layouts.\n  // e.g. {lg: Layout, md: Layout, ...}\n  layouts: function layouts(props, propName) {\n    if (type(props[propName]) !== \"[object Object]\") {\n      throw new Error(\"Layout property must be an object. Received: \" + type(props[propName]));\n    }\n\n    Object.keys(props[propName]).forEach(function (key) {\n      if (!(key in props.breakpoints)) {\n        throw new Error(\"Each key in layouts must align with a key in breakpoints.\");\n      }\n\n      (0, _utils.validateLayout)(props.layouts[key], \"layouts.\" + key);\n    });\n  },\n  // The width of this component.\n  // Required in this propTypes stanza because generateInitialState() will fail without it.\n  width: _propTypes2.default.number.isRequired,\n  //\n  // Callbacks\n  //\n  // Calls back with breakpoint and new # cols\n  onBreakpointChange: _propTypes2.default.func,\n  // Callback so you can save the layout.\n  // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.\n  onLayoutChange: _propTypes2.default.func,\n  // Calls back with (containerWidth, margin, cols, containerPadding)\n  onWidthChange: _propTypes2.default.func\n};\nResponsiveReactGridLayout.defaultProps = {\n  breakpoints: {\n    lg: 1200,\n    md: 996,\n    sm: 768,\n    xs: 480,\n    xxs: 0\n  },\n  cols: {\n    lg: 12,\n    md: 10,\n    sm: 6,\n    xs: 4,\n    xxs: 2\n  },\n  layouts: {},\n  onBreakpointChange: _utils.noop,\n  onLayoutChange: _utils.noop,\n  onWidthChange: _utils.noop\n};\nexports.default = ResponsiveReactGridLayout;","map":null,"metadata":{},"sourceType":"script"}