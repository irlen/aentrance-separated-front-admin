{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @file\n */\n\n/* global map BMap */\n\nvar roadColor = {\n  0: '#fff',\n  1: '#00dc35',\n  2: '#f3e032',\n  3: '#ff6c6c',\n  4: '#900000'\n};\nvar mapLine = {\n  /**\n   * roads [\"116,40,117,59\",\"116,40,117,59\",...]\n   */\n  drawRoads: function drawRoads(map, ctx, roads) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var zoom = map.getZoom();\n    var lineWidth = options.lineWidth || 5;\n    var level = options.level === undefined ? 1 : options.level;\n    var pointTem = null;\n    var dep = 0;\n    var lineTotalDepth = 0; // arrow info\n\n    var points = [];\n    var allPoints = [];\n    var arrowPoint = [];\n    var arrpwTotalDepth = 0;\n    var totalDepth = 0; //\n\n    ctx.beginPath();\n    var pixel;\n    var zoomUnit = Math.pow(2, 18 - map.getZoom());\n    var projection = map.getMapType().getProjection();\n    var mcCenter = projection.lngLatToPoint(map.getCenter());\n    var nwMc = new BMap.Pixel(mcCenter.x - map.getSize().width / 2 * zoomUnit, mcCenter.y + map.getSize().height / 2 * zoomUnit); //左上角墨卡托坐标\n\n    roads.forEach(function (item, index) {\n      var startPos = null;\n      pointTem = null;\n      var path = item.split(',');\n\n      for (var k = 0; k < path.length; k += 2) {\n        var point = new BMap.Point(path[k], path[k + 1]);\n        allPoints.push(point);\n\n        if (options.coordType === 'bd09mc') {\n          pixel = {\n            x: (point.lng - nwMc.x) / zoomUnit,\n            y: (nwMc.y - point.lat) / zoomUnit\n          };\n        } else {\n          pixel = map.pointToPixel(point);\n        }\n\n        var arrowInfo = void 0;\n\n        if (pointTem) {\n          var deltaX = pixel.x - pointTem.x;\n          var deltaY = pixel.y - pointTem.y;\n          dep = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n          lineTotalDepth += dep; // arrow\n\n          if (options.arrow) {\n            arrpwTotalDepth += dep;\n            totalDepth += dep;\n            arrowInfo = {\n              start: pointTem,\n              end: pixel,\n              offset: 50 - (arrpwTotalDepth - dep),\n              depth: dep,\n              totalDepth: totalDepth\n            };\n            points.push(arrowInfo);\n\n            if (arrpwTotalDepth >= 50) {\n              arrowPoint.push(arrowInfo);\n              arrpwTotalDepth %= 50;\n            }\n          } //\n\n        }\n\n        pointTem = pixel; // console.log(pixel, k)\n\n        if (k === 0) {\n          startPos = startPos || pixel;\n          ctx.moveTo(pixel.x, pixel.y);\n        } else if (lineTotalDepth > 15 || k >= path.length - 2) {\n          lineTotalDepth = 0;\n          ctx.lineTo(pixel.x, pixel.y);\n        }\n      } // for arrow\n      // if the line is too short\n\n\n      if (options.arrow) {\n        if (index === item.length - 1 && totalDepth < 100) {\n          var center = points[Math.ceil(points.length / 2)];\n\n          for (var i in points) {\n            if (points[i].totalDepth >= totalDepth / 2) {\n              center = points[i + 1] ? points[i + 1] : points[i];\n              break;\n            }\n          }\n\n          var end = points[points.length - 1];\n          center.end = end.end;\n          arrowPoint = [];\n          arrowPoint.push(center);\n        }\n      }\n    });\n\n    if (options.line) {\n      ctx.lineCap = options.lineCap || 'round';\n      ctx.lineJoin = 'round';\n\n      if (options.border) {\n        ctx.strokeStyle = options.border.color || 'white';\n        ctx.lineWidth = (zoom <= 13 ? lineWidth - 2 : lineWidth) + (options.border.lineWidth * 2 || 4);\n        ctx.stroke();\n      }\n\n      ctx.strokeStyle = options.color || roadColor[level] || '#fc2c2b';\n      ctx.lineWidth = zoom <= 13 ? lineWidth - 2 : lineWidth; // console.log(ctx);\n\n      ctx.stroke();\n    } //\n\n\n    if (options.arrow) {\n      //if (zoom > 13) {\n      this.drawArrow(ctx, arrowPoint, options); //}\n    }\n\n    return allPoints;\n  },\n  drawArrow: function drawArrow(ctx, arrowPoint, options) {\n    // draw active arrow\n    ctx.beginPath();\n    arrowPoint.forEach(function (item) {\n      var startX = item.start.x;\n      var startY = item.start.y;\n      var endX = item.end.x;\n      var endY = item.end.y;\n      var depthX = endX - startX;\n      var depthY = endY - startY;\n      var vOrigin = [0, -1];\n      var vItem = [item.end.x - item.start.x, item.end.y - item.start.y];\n      var angleVar1 = vOrigin[0] * vItem[0] + vOrigin[1] * vItem[1];\n      var angleVar2 = Math.sqrt(vOrigin[0] * vOrigin[0] + vOrigin[1] * vOrigin[1]);\n      var angleVar3 = Math.sqrt(vItem[0] * vItem[0] + vItem[1] * vItem[1]);\n      var angle = Math.acos(angleVar1 / (angleVar2 * angleVar3));\n\n      if (vItem[0] < 0) {\n        angle = Math.PI * 2 - angle;\n      }\n\n      var width = options.arrow.width / 2 || 2;\n      var height = options.arrow.height || width;\n      var loop = 0;\n\n      while (item.offset + 50 * loop <= item.depth) {\n        var offset = item.offset + 50 * loop;\n        var offsetPresent = offset / item.depth;\n        ctx.save();\n        ctx.translate(startX + depthX * offsetPresent, startY + depthY * offsetPresent);\n        ctx.rotate(angle);\n        ctx.moveTo(-width * 1.618, height);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(width * 1.618, height);\n        ctx.restore();\n        loop += 1;\n      }\n\n      if (arrowPoint.length === 1 && item.offset > item.depth) {\n        ctx.save();\n        ctx.translate(startX, startY);\n        ctx.rotate(angle);\n        ctx.moveTo(-width * 1.618, height);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(width * 1.618, height);\n        ctx.restore();\n      }\n    });\n    ctx.strokeStyle = options.arrow.color || '#fff';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n  }\n};\nexports.default = mapLine;","map":null,"metadata":{},"sourceType":"script"}