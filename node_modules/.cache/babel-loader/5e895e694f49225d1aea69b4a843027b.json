{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _component = require('./component');\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _mapv = require('mapv');\n\nvar _mapLine = require('../utils/map-line');\n\nvar _mapLine2 = _interopRequireDefault(_mapLine);\n\nvar _geoUtils = require('../utils/geo-utils');\n\nvar _geoUtils2 = _interopRequireDefault(_geoUtils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * @file 道路组件\n * nikai@baidu.com\n */\n\n\nvar App = function (_Component) {\n  _inherits(App, _Component);\n\n  function App(args) {\n    _classCallCheck(this, App);\n\n    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, args));\n\n    _this.state = {};\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      this.initialize();\n    }\n  }, {\n    key: 'getRoadPoints',\n    value: function getRoadPoints(roadPath) {\n      var projection = this.props.map.getMapType().getProjection();\n      var points = [];\n\n      for (var i = 0; i < roadPath.length; i++) {\n        var tmp = roadPath[i].split(',');\n\n        for (var j = 0; j < tmp.length; j += 2) {\n          if (this.props.coordType === 'bd09mc') {\n            points.push(projection.pointToLngLat(new BMap.Pixel(tmp[j], tmp[j + 1])));\n          } else {\n            points.push(new BMap.Point(tmp[j], tmp[j + 1]));\n          }\n        }\n      }\n\n      return points;\n    }\n  }, {\n    key: 'updateViewport',\n    value: function updateViewport() {\n      var _this2 = this;\n\n      var roadPath = this.props.roadPath;\n      var points = [];\n\n      if (this.props.roadPaths) {\n        this.props.roadPaths.forEach(function (roadPath) {\n          points = points.concat(_this2.getRoadPoints(roadPath));\n        });\n      } else if (this.props.roadPath) {\n        points = points.concat(this.getRoadPoints(this.props.roadPath));\n      }\n\n      if (points.length > 0 && this.props.autoViewport !== false) {\n        this.props.map.setViewport(points, this.props.viewportOptions);\n      }\n    }\n  }, {\n    key: 'getRoadGroup',\n    value: function getRoadGroup(roadPath, category, splitList) {\n      var roadPath = roadPath;\n      var category = category;\n      var splitList = splitList;\n      var data = {};\n      var allPath = [];\n\n      if (category) {\n        for (var i = 0; i < category.length; i++) {\n          if (!data[category[i]]) {\n            data[category[i]] = {\n              roadPath: [],\n              color: splitList[category[i]]\n            };\n          }\n\n          allPath.push(roadPath[i]);\n          data[category[i]].roadPath.push(roadPath[i]);\n        }\n      } else {\n        data[0] = {\n          roadPath: roadPath,\n          color: this.props.color || '#1495ff'\n        };\n      }\n\n      return {\n        group: data,\n        allPath: _geoUtils2.default.mergeRoadPath(roadPath)\n      };\n    }\n  }, {\n    key: 'isClick',\n    value: function isClick(map, pixel, roadPath) {\n      var ctx = this.canvasLayer.canvas.getContext('2d');\n      var roadGroup = this.getRoadGroup(roadPath);\n      ctx.beginPath();\n      var lineWidth = this.props.lineWidth || 10;\n\n      _mapLine2.default.drawRoads(map, ctx, roadGroup.allPath, {\n        color: this.props.bgColor || '#fff',\n        lineWidth: lineWidth + 4,\n        lineCap: 'butt',\n        arrow: false,\n        line: false\n      });\n\n      ctx.lineWidth = lineWidth + 6;\n      var isPointInStroke = ctx.isPointInStroke(pixel.x * window.devicePixelRatio, pixel.y * window.devicePixelRatio);\n      return isPointInStroke;\n    }\n  }, {\n    key: 'initialize',\n    value: function initialize() {\n      var _this3 = this;\n\n      var map = this.props.map;\n\n      if (!map) {\n        return;\n      }\n\n      var _update = this.canvasLayerUpdate.bind(this);\n\n      if (this.canvasLayer) {\n        this.canvasLayer.draw();\n      } else {\n        this.canvasLayer = new _mapv.baiduMapCanvasLayer({\n          zIndex: this.props.zIndex,\n          map: map,\n          update: function update() {\n            _update(this);\n          }\n        });\n\n        if (this.props.onClick) {\n          map.addEventListener('click', function (e) {\n            var isClick = false;\n\n            if (_this3.props.roadPaths) {\n              for (var i = 0; i < _this3.props.roadPaths.length; i++) {\n                var roadPath = _this3.props.roadPaths[i];\n                isClick = _this3.isClick(map, e.pixel, roadPath);\n\n                if (isClick) {\n                  _this3.props.onClick(i);\n                }\n              }\n\n              ;\n            } else if (_this3.props.roadPath) {\n              isClick = _this3.isClick(map, e.pixel, _this3.props.roadPath);\n\n              if (isClick) {\n                _this3.props.onClick();\n              }\n            }\n          });\n        }\n      }\n\n      this.updateViewport();\n    }\n  }, {\n    key: 'canvasLayerUpdate',\n    value: function canvasLayerUpdate(canvasLayer) {\n      var _this4 = this;\n\n      var ctx = canvasLayer.canvas.getContext('2d');\n\n      if (!ctx) {\n        return false;\n      }\n\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      var roadPath = this.props.roadPath;\n      var roadPaths = this.props.roadPaths;\n      var lineWidth = this.props.lineWidth || 10;\n\n      if (roadPaths) {\n        roadPaths.forEach(function (roadPath, index) {\n          if (_this4.props.lineWidths) {\n            lineWidth = _this4.props.lineWidths[index];\n          }\n\n          _this4.drawRoad(ctx, roadPath, _this4.props.category, _this4.props.splitList, lineWidth);\n        });\n      } else if (roadPath) {\n        this.drawRoad(ctx, this.props.roadPath, this.props.category, this.props.splitList, lineWidth);\n      }\n    }\n  }, {\n    key: 'drawRoad',\n    value: function drawRoad(ctx, roadPath, category, splitList, lineWidth) {\n      var roadGroup = this.getRoadGroup(roadPath, category, splitList);\n      var data = roadGroup.group;\n\n      _mapLine2.default.drawRoads(this.props.map, ctx, roadGroup.allPath, {\n        color: this.props.bgColor || '#fff',\n        coordType: this.props.coordType,\n        lineWidth: lineWidth + 4,\n        lineCap: 'butt',\n        arrow: false,\n        line: true\n      });\n\n      for (var key in data) {\n        var item = data[key];\n\n        var roadPath = _geoUtils2.default.mergeRoadPath(item.roadPath);\n\n        _mapLine2.default.drawRoads(this.props.map, ctx, roadPath, {\n          color: item.color,\n          coordType: this.props.coordType,\n          line: true,\n          lineWidth: lineWidth,\n          lineCap: 'butt',\n          arrow: false\n        });\n      }\n\n      ;\n\n      _mapLine2.default.drawRoads(this.props.map, ctx, roadGroup.allPath, {\n        color: item.color,\n        coordType: this.props.coordType,\n        lineWidth: lineWidth,\n        border: {},\n        lineCap: 'butt',\n        arrow: this.props.isShowArrow !== false ? {\n          width: 5,\n          height: 3,\n          color: this.props.arrowColor\n        } : false\n      });\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.initialize();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.canvasLayer.hide();\n    }\n  }]);\n\n  return App;\n}(_component2.default);\n\nexports.default = App;","map":null,"metadata":{},"sourceType":"script"}