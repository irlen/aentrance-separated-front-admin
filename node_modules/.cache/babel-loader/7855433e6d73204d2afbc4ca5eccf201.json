{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _component = require('./component');\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _mapv = require('mapv');\n\nvar _NumberMarker = require('../overlay/NumberMarker');\n\nvar _NumberMarker2 = _interopRequireDefault(_NumberMarker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar App = function (_Component) {\n  _inherits(App, _Component);\n\n  function App(args) {\n    _classCallCheck(this, App);\n\n    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, args));\n\n    _this.state = {};\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var preData = JSON.stringify(prevProps.data);\n      var data = JSON.stringify(this.props.data);\n\n      if (preData != data || !this.map) {\n        this.initialize();\n      } else {\n        this.setViewport();\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.markers = [];\n      this.initialize();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.clearMarkers();\n\n      if (this.textLayer) {\n        this.textLayer.destroy();\n        this.textLayer = null;\n      }\n\n      if (this.animationLayer) {\n        this.animationLayer.destroy();\n        this.animationLayer = null;\n      }\n    }\n  }, {\n    key: 'clearMarkers',\n    value: function clearMarkers() {\n      for (var i = 0; i < this.markers.length; i++) {\n        this.map.removeOverlay(this.markers[i]);\n        this.markers[i] = null;\n      }\n\n      this.markers.length = 0;\n    }\n  }, {\n    key: 'initialize',\n    value: function initialize() {\n      var self = this;\n      var map = this.props.map;\n\n      if (!map) {\n        return;\n      }\n\n      this.map = map;\n      this.clearMarkers();\n\n      if (!this.textLayer) {\n        this.dataSet = new _mapv.DataSet([]);\n        var options = this.props.textOptions || {\n          fillStyle: '#666666',\n          shadowBlur: 5,\n          shadowColor: 'rgba(0, 0, 0, 0.1)',\n          globalAlpha: '0.9',\n          textAlign: 'left',\n          offset: {\n            x: this.props.mini ? 10 : 15,\n            y: 0\n          },\n          coordType: this.props.coordType,\n          avoid: true,\n          size: 12,\n          textKey: 'text',\n          draw: 'text'\n        };\n\n        if (this.props.isShowText !== false) {\n          this.textLayer = new _mapv.baiduMapLayer(map, this.dataSet, options);\n        }\n      }\n\n      if (!this.animationLayer && this.props.animation === true) {\n        var splitList = this.props.splitList || {};\n        splitList.other = this.props.fillStyle || 'rgba(50, 50, 255, 0.5)';\n        var animationOptions = {\n          styleType: 'stroke',\n          strokeStyle: this.props.fillStyle || 'rgba(20, 249, 255, 0.5)',\n          coordType: this.props.coordType,\n          splitList: splitList,\n          globalAlpha: 0.4,\n          size: this.props.multiple || this.props.mini ? 20 : 26,\n          minSize: this.props.multiple || this.props.mini ? 10 : 13,\n          draw: 'category'\n        };\n        this.animationLayer = new _mapv.baiduMapAnimationLayer(map, this.dataSet, animationOptions);\n      }\n\n      var projection = map.getMapType().getProjection();\n      var data = this.props.data;\n      var mapvData = [];\n\n      for (var i = 0; i < data.length; i++) {\n        if (this.props.showIndex !== undefined && this.props.showIndex != i) {\n          continue;\n        }\n\n        if (data[i].location) {\n          var location = data[i].location.split(',');\n\n          if (this.props.coordType && this.props.coordType === 'bd09mc') {\n            var point = projection.pointToLngLat(new BMap.Pixel(location[0], location[1]));\n          } else {\n            var point = new BMap.Point(location[0], location[1]);\n          }\n\n          var fillStyle = data[i].color || this.props.fillStyle || '#1495ff';\n\n          if (this.props.splitList) {\n            if (this.props.splitList[data[i].count]) {\n              fillStyle = this.props.splitList[data[i].count];\n            } else {\n              fillStyle = this.props.splitList.other;\n            }\n          }\n\n          var options = {\n            point: point,\n            fillStyle: fillStyle,\n            isShowNumber: this.props.isShowNumber,\n            size: 26,\n            zIndex: data.length - i,\n            number: i + 1\n          };\n\n          if (this.props.multiple || this.props.mini) {\n            options.size = 20;\n            options.lineWidth = 0;\n\n            if (i >= 10 || this.props.mini) {\n              options.isShowNumber = false;\n              options.size = 10;\n              options.strokeStyle = fillStyle;\n              options.lineWidth = 3;\n              options.strokeOpacity = 0.4;\n            }\n          }\n\n          var marker = new _NumberMarker2.default(options);\n          marker.addEventListener('click', function (e, number) {\n            self.props.onClick && self.props.onClick(number - 1);\n          });\n          marker.addEventListener('mouseover', function (e, number) {\n            self.props.onMouseOver && self.props.onMouseOver(number - 1);\n          });\n          marker.addEventListener('mouseout', function (e, number) {\n            self.props.onMouseOut && self.props.onMouseOut(number - 1);\n          });\n          marker.index = i;\n          this.markers.push(marker);\n          mapvData.push({\n            geometry: {\n              type: 'Point',\n              coordinates: [location[0], location[1]]\n            },\n            count: data[i].count,\n            text: data[i].text\n          });\n        }\n      }\n\n      var length = this.markers.length;\n\n      while (length--) {\n        map.addOverlay(this.markers[length]);\n      }\n\n      if (this.props.mini) {\n        this.dataSet.set(mapvData);\n      } else {\n        this.dataSet.set(mapvData.splice(0, 10));\n      }\n\n      this.setViewport();\n    }\n  }, {\n    key: 'setViewport',\n    value: function setViewport() {\n      var map = this.props.map;\n\n      if (!map) {\n        return;\n      }\n\n      var data = this.props.data;\n      var projection = map.getMapType().getProjection();\n      var points = [];\n\n      for (var i = 0; i < data.length; i++) {\n        if (data[i].location) {\n          var location = data[i].location.split(',');\n\n          if (this.props.coordType && this.props.coordType === 'bd09mc') {\n            var point = projection.pointToLngLat(new BMap.Pixel(location[0], location[1]));\n          } else {\n            var point = new BMap.Point(location[0], location[1]);\n          }\n\n          points.push(point);\n        }\n      }\n\n      if (points.length > 0 && this.props.autoViewport !== false) {\n        map.setViewport(points, this.props.viewportOptions);\n      }\n    }\n  }], [{\n    key: 'defaultProps',\n    get: function get() {\n      return {\n        autoViewport: true\n      };\n    }\n  }]);\n\n  return App;\n}(_component2.default);\n\nexports.default = App;","map":null,"metadata":{},"sourceType":"script"}